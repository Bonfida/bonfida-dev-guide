# Implementing checks on third-party state

In the above discussion, we have determined that our vault should be owned by an account our program controls and can sign for.
This is where program-derived addresses (PDAs) come into play.

## Aside: what are Program-Derived Addresses (PDAs)?

PDAs are Solana's solution for a recurring generic problem in program design : how can our program _own_ anything of value?
Conventionally, owning an asset on a blockchain means controlling a private key the public key of which is set as its _owner_.
Then, users can sign transactions to authorize operations on assets they own.
They key to all of this is that the private key is only known to its owner.

Sometimes, we need a program to own something in the same way that a user does.
However, any information a program has access to is available to anyone, so we can't really give a private key to our program.
What we need is a public key which isn't tied to a private key, but instead to a particular program.
This is precisely what PDAs are.

A PDA is uniquely derived from an array of _seeds_.
To generate a PDA, we can use one of two methods `Pubkey::find_program_address`, or `Pubkey::create_program_address`.
The difference between the two is that `create_program_address` needs _valid_ seeds which generate a valid PDA.
A valid PDA is a Pubkey which we're sure doesn't have a private key.
It lies outside the `ed25519` curve used by Solana.
`find_program_address` will take a seed array and find a `u8` to add to the seed array such that the resulting array is a valid PDA seed.
We call this `u8` the `signer_nonce`.

We can relate the two methods:

```rust,noplayground
let seeds: &[u8] = &[...];
let (k, nonce) = Pubkey::find_program_address(&[seeds], program_id).unwrap();
let k2 = Pubkey::create_program_ddress(&[seeds, &[signer_nonce]]).unwrap();
// k and k2 will be the same
assert_eq!(k, k2);
```

In general, `find_program_address` can be relatively inefficient: it loops over potential nonces until it finds a valid one.
The real issue is that the length of this loop is quite unpredictable.
In most cases, it will be very short.
This means that the entirety of your testing scenarios can only test for short loops, and edge cases can show up in production later down the line.
Therefore, as a general rule of thumb, `find_program_address` should be avoided on-chain because it consumes an unreliable amount of compute budget.
There are exceptions to this rule, especially when PDAs are used as a mapping function.
This is why we ask the user to provide a `signer_nonce`: `find_program_address` is executed off-chain.

A PDA's seeds serve a similar purpose to a private key.
When a program needs to sign for a PDA, it uses the PDA's seeds in a call to `invoke_signed`.
The runtime can then make sure that the PDA to sign for corresponds to those seeds and the calling program.

To add a layer of security, we want our vesting contract instances to be as compartmentalized as possible.
Therefore, we will use the `VestingContract` key as seeds.
Each instance already has its own vault, and this allows each contract to have its own separate signing authority.
The altenative to this is related to the idea of _central state_, which can be required by some use cases and is supported by `bonfida-utils`.

## Writing the `check_vault_account` method

Using the constraints we came up with by analyzing the `spl_token::Account` struct, we can add to `create.rs`:

```rust,noplayground
fn check_vault_account(
    vault: &AccountInfo,
    program_id: &Pubkey,
    contract_key: Pubkey,
    signer_nonce: u8,
) -> Result<(), ProgramError> {
    // We parse the Account struct using the Solana-provided Pack trait
    let vault_account = spl_token::state::Account::unpack(&vault.data.borrow())?;

    let vault_signer =
        Pubkey::create_program_address(&[&contract_key.to_bytes(), &[signer_nonce]], program_id)?;
    let is_valid = vault_account.owner == vault_signer
        && vault_account.amount == 0
        && vault_account.delegate.is_none()
        && vault_account.state == AccountState::Initialized
        && vault_account.close_authority.is_none();
    if !is_valid {
        return Err(TokenVestingError::InvalidVaultAccount.into());
    }
    Ok(())
}
```

If the provided vault account is invalid, we return the custom `InvalidVaultAccount` error.
Let's define it in `error.rs` by modifyin the `TokenVestingError` struct:

```rust,noplayground
#[derive(Clone, Debug, Error, FromPrimitive)]
pub enum TokenVestingError {
    #[error("This account is already initialized")]
    AlreadyInitialized,
    #[error("Data type mismatch")]
    DataTypeMismatch,
    #[error("Wrong account owner")]
    WrongOwner,
    #[error("Account is uninitialized")]
    Uninitialized,
    #[error("The provided vault account is invalid")]
    InvalidVaultAccount,
}
```

Our project does not compile at this point, and we need to edit `TokenVestingError`'s impl of the `PrintProgramError` trait in `entrypoint.rs`:

```rust,noplayground
impl PrintProgramError for TokenVestingError {
    fn print<E>(&self)
    where
        E: 'static + std::error::Error + DecodeError<E> + PrintProgramError + FromPrimitive,
    {
        match self {
            TokenVestingError::AlreadyInitialized => {
                msg!("Error: This account is already initialized")
            }
            TokenVestingError::DataTypeMismatch => msg!("Error: Data type mismatch"),
            TokenVestingError::WrongOwner => msg!("Error: Wrong account owner"),
            TokenVestingError::Uninitialized => msg!("Error: Account is uninitialized"),
            TokenVestingError::InvalidVaultAccount => {
                msg!("Error: The provided vault account is invalid")
            }
        }
    }
}
```

It might seem a bit redundant to have the same error message appear twice in our project.
However, doing it this way prevents our `PrintProgramError` implementation from having to use string formatting which is inefficient on-chain.
The last thing we want is our error messages to be buried under a `ComputationalBudgetExceeded` error.

Finally we just have to insert a call to `check_vault_account` in our `create` instruction's logic:

```rust,noplayground
check_vault_account(
    accounts.vault,
    program_id,
    *accounts.vesting_contract.key,
    signer_nonce,
)?;
```

If you've been following along, your `create.rs` file is in its final form and should look like this:

```rust,noplayground
//! Create a new token vesting contract

use bonfida_utils::{checks::check_account_owner, WrappedPod};
use solana_program::{msg, program::invoke, program_pack::Pack};
use spl_token::state::AccountState;

use crate::{
    error::TokenVestingError,
    state::{
        self,
        vesting_contract::{VestingContract, VestingContractHeader, VestingSchedule},
    },
};

use {
    bonfida_utils::{
        checks::{check_account_key, check_signer},
        InstructionsAccount,
    },
    solana_program::{
        account_info::{next_account_info, AccountInfo},
        entrypoint::ProgramResult,
        program_error::ProgramError,
        pubkey::Pubkey,
    },
};

#[derive(WrappedPod)]
pub struct Params<'a> {
    signer_nonce: &'a u64,
    schedule: &'a [VestingSchedule],
}

#[derive(InstructionsAccount)]
pub struct Accounts<'a, T> {
    /// SPL token program account
    pub spl_token_program: &'a T,

    /// The account which will store the [`VestingContract`] data structure
    #[cons(writable)]
    pub vesting_contract: &'a T,

    /// The contract's escrow vault
    #[cons(writable)]
    pub vault: &'a T,

    #[cons(writable)]
    /// The account currently holding the tokens to be vested
    pub source_tokens: &'a T,

    #[cons(signer)]
    /// The owner of the account currently holding the tokens to be vested
    pub source_tokens_owner: &'a T,

    /// The eventual recipient of the vested tokens
    pub recipient: &'a T,
}

impl<'a, 'b: 'a> Accounts<'a, AccountInfo<'b>> {
    pub fn parse(
        accounts: &'a [AccountInfo<'b>],
        program_id: &Pubkey,
    ) -> Result<Self, ProgramError> {
        let accounts_iter = &mut accounts.iter();
        let accounts = Accounts {
            spl_token_program: next_account_info(accounts_iter)?,
            vesting_contract: next_account_info(accounts_iter)?,
            vault: next_account_info(accounts_iter)?,
            source_tokens: next_account_info(accounts_iter)?,
            source_tokens_owner: next_account_info(accounts_iter)?,
            recipient: next_account_info(accounts_iter)?,
        };

        // Check keys
        check_account_key(accounts.spl_token_program, &spl_token::ID)?;

        // Check owners
        check_account_owner(accounts.vesting_contract, program_id)?;
        check_account_owner(accounts.vault, &spl_token::ID)?;

        // Check signer
        check_signer(accounts.source_tokens_owner)?;

        Ok(accounts)
    }
}

pub fn process(program_id: &Pubkey, accounts: &[AccountInfo], params: Params) -> ProgramResult {
    let accounts = Accounts::parse(accounts, program_id)?;

    let Params {
        signer_nonce,
        schedule,
    } = params;

    // We only want a one-byte signer nonce
    let signer_nonce = *signer_nonce as u8;

    let expected_vesting_contract_account_size =
        VestingContract::compute_allocation_size(schedule.len());

    if accounts.vesting_contract.data_len() != expected_vesting_contract_account_size {
        msg!("The vesting contract account is incorrectly sized for the supplied schedule!");
        return Err(ProgramError::InvalidArgument);
    }

    check_vault_account(
        accounts.vault,
        program_id,
        *accounts.vesting_contract.key,
        signer_nonce,
    )?;

    let mut vesting_contract_guard = accounts.vesting_contract.data.borrow_mut();

    VestingContract::initialize(&mut vesting_contract_guard)?;
    let vesting_contract =
        VestingContract::from_buffer(&mut vesting_contract_guard, state::Tag::VestingContract)?;

    *vesting_contract.header = VestingContractHeader {
        owner: *accounts.recipient.key,
        vault: *accounts.vault.key,
        current_schedule_index: 0,
        signer_nonce,
        _padding: [0; 7],
    };

    let mut total_amount = 0u64;
    for (schedule, slot) in schedule.iter().zip(vesting_contract.schedules.iter_mut()) {
        *slot = *schedule;
        total_amount = total_amount.checked_add(schedule.quantity).unwrap();
    }

    let instruction = spl_token::instruction::transfer(
        &spl_token::ID,
        accounts.source_tokens.key,
        accounts.vault.key,
        accounts.source_tokens_owner.key,
        &[],
        total_amount,
    )?;

    invoke(
        &instruction,
        &[
            accounts.spl_token_program.clone(),
            accounts.source_tokens.clone(),
            accounts.vault.clone(),
            accounts.source_tokens_owner.clone(),
        ],
    )?;

    Ok(())
}

fn check_vault_account(
    vault: &AccountInfo,
    program_id: &Pubkey,
    contract_key: Pubkey,
    signer_nonce: u8,
) -> Result<(), ProgramError> {
    let vault_account = spl_token::state::Account::unpack(&vault.data.borrow())?;

    let vault_signer =
        Pubkey::create_program_address(&[&contract_key.to_bytes(), &[signer_nonce]], program_id)?;
    let is_valid = vault_account.owner == vault_signer
        && vault_account.amount == 0
        && vault_account.delegate.is_none()
        && vault_account.state == AccountState::Initialized
        && vault_account.close_authority.is_none();
    if !is_valid {
        return Err(TokenVestingError::InvalidVaultAccount.into());
    }
    Ok(())
}
```